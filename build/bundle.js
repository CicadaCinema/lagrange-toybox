var app=function(){"use strict";function t(){}function e(t){return t()}function n(){return Object.create(null)}function o(t){t.forEach(e)}function r(t){return"function"==typeof t}function i(t,e){return t!=t?e==e:t!==e||t&&"object"==typeof t||"function"==typeof t}function a(t,e,n){t.insertBefore(e,n||null)}function s(t){t.parentNode.removeChild(t)}function c(t){return document.createElement(t)}function l(){return t=" ",document.createTextNode(t);var t}function u(t,e,n){null==n?t.removeAttribute(e):t.getAttribute(e)!==n&&t.setAttribute(e,n)}let d;function f(t){d=t}const p=[],g=[],h=[],m=[],$=Promise.resolve();let b=!1;function y(t){h.push(t)}let v=!1;const x=new Set;function _(){if(!v){v=!0;do{for(let t=0;t<p.length;t+=1){const e=p[t];f(e),w(e.$$)}for(f(null),p.length=0;g.length;)g.pop()();for(let t=0;t<h.length;t+=1){const e=h[t];x.has(e)||(x.add(e),e())}h.length=0}while(p.length);for(;m.length;)m.pop()();b=!1,v=!1,x.clear()}}function w(t){if(null!==t.fragment){t.update(),o(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(y)}}const j=new Set;function k(t,e){-1===t.$$.dirty[0]&&(p.push(t),b||(b=!0,$.then(_)),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function O(i,a,c,l,u,p,g,h=[-1]){const m=d;f(i);const $=i.$$={fragment:null,ctx:null,props:p,update:t,not_equal:u,bound:n(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(a.context||(m?m.$$.context:[])),callbacks:n(),dirty:h,skip_bound:!1,root:a.target||m.$$.root};g&&g($.root);let b=!1;if($.ctx=c?c(i,a.props||{},((t,e,...n)=>{const o=n.length?n[0]:e;return $.ctx&&u($.ctx[t],$.ctx[t]=o)&&(!$.skip_bound&&$.bound[t]&&$.bound[t](o),b&&k(i,t)),e})):[],$.update(),b=!0,o($.before_update),$.fragment=!!l&&l($.ctx),a.target){if(a.hydrate){const t=function(t){return Array.from(t.childNodes)}(a.target);$.fragment&&$.fragment.l(t),t.forEach(s)}else $.fragment&&$.fragment.c();a.intro&&((v=i.$$.fragment)&&v.i&&(j.delete(v),v.i(x))),function(t,n,i,a){const{fragment:s,on_mount:c,on_destroy:l,after_update:u}=t.$$;s&&s.m(n,i),a||y((()=>{const n=c.map(e).filter(r);l?l.push(...n):o(n),t.$$.on_mount=[]})),u.forEach(y)}(i,a.target,a.anchor,a.customElement),_()}var v,x;f(m)}function A(e){let n,o,r;return{c(){n=c("div"),o=l(),r=c("div"),r.innerHTML='<div class="inner svelte-dosjyx"><dialog open="" class="svelte-dosjyx"><h2>Usage</h2> \n            <ol><li>Select &quot;Tools&quot; in the sidebar.</li> \n                <li>Under &quot;Basic Tools&quot; select &quot;Point&quot;.</li> \n                <li>Click anywhere on the graph to add a point. Continue adding points by clicking on an empty area of\n                    the graph, or click and drag an existing point to move it.</li></ol> \n            <p>A single polynomial should be plotted, which passes through all the points.</p> \n            <form method="dialog"><button>OK</button></form></dialog></div>',u(n,"class","main svelte-dosjyx"),u(n,"id","ggb-element"),u(r,"class","outer svelte-dosjyx")},m(t,e){a(t,n,e),a(t,o,e),a(t,r,e)},p:t,i:t,o:t,d(t){t&&s(n),t&&s(o),t&&s(r)}}}function L(t){var e={appName:"graphing",scaleContainerClass:"main",showToolBar:!0,showAlgebraInput:!0,showMenuBar:!0,appletOnLoad:function(t){function e(){let n=[],o=t.getObjectNumber();for(var r=0;r<o;r++){let e=t.getObjectName(r);"point"==t.getObjectType(e)&&n.push([t.getXcoord(e),t.getYcoord(e)])}let i="";for(let t of n){let e=`${t[1]}`;for(let o of n)o!=t&&(e+=`*(x-${o[0]})*(${t[0]}-${o[0]})^-1`);i+=`+(${e})`}t.unregisterUpdateListener(e),t.evalCommand(`ParseToFunction(f, "${i}")`),t.registerUpdateListener(e)}t.renameObject(t.evalCommandGetLabels("x"),"f"),t.registerAddListener(e),t.registerUpdateListener(e)}},n=new GGBApplet(e,!0);return window.addEventListener("load",(function(){n.inject("ggb-element")})),[]}return new class extends class{$destroy(){!function(t,e){const n=t.$$;null!==n.fragment&&(o(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}(this,1),this.$destroy=t}$on(t,e){const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(e),()=>{const t=n.indexOf(e);-1!==t&&n.splice(t,1)}}$set(t){var e;this.$$set&&(e=t,0!==Object.keys(e).length)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}{constructor(t){super(),O(this,t,L,A,i,{})}}({target:document.body})}();
//# sourceMappingURL=bundle.js.map
